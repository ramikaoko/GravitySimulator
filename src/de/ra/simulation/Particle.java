package de.ra.simulation;

import java.awt.Point;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Point2D;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;

import javax.vecmath.Vector2d;

/* The particle class contains all properties of a particle and the methods to calculate velocity, the vector, the radius, and the shape */
public class Particle {

	/* The unique id for the particle */
	private final int uniqueId;

	/*
	 * Used to generate uniqueIds, AtomicInteger is useful because of the
	 * getAndIncrement() method
	 */
	private static AtomicInteger COUNTER = new AtomicInteger(0);

	private double mass;

	private double density;

	private double radius;

	/* The location of a particle in the content panel */
	private Point2D location;

	/* The vector of a particle in the content panel */
	private Vector2d vector = new Vector2d();

	/*
	 * The velocity of a particle is determined by the distance of the start and
	 * end point of the mouse movement in MainFrame() and a random integer.
	 */
	private double velocity;

	/* A multiplier for velocity so the user can change the it if he wants to */
	private int velocityMultiplier;

	/*
	 * If the value for velocity becomes to big, the particles can't be drawn
	 * fast enough, therefore we define a limit of 150
	 */
	private static final double MAX_VELOCITY = 150;

	/*
	 * --- getter and setter ---
	 */
	public double getMass() {
		return mass;
	}

	public void setMass(double mass) {
		this.mass = mass;
	}

	public double getDensity() {
		return density;
	}

	public void setDensity(double density) {
		this.density = density;
	}

	public double getRadius() {
		return radius;
	}

	public Vector2d getVector() {
		return new Vector2d(vector);
	}

	public Point2D getLocation() {
		return location;
	}

	public double getVelocity() {
		return velocity;
	}

	public void setVelocity(double velocity) {
		this.velocity = Math.min(velocity, MAX_VELOCITY);
	}

	public int getId() {
		return uniqueId;
	}

	/* A new unique id is generated by incrementing the COUNTER value */
	private static int getNewId() {
		synchronized (COUNTER) {
			int newID = COUNTER.incrementAndGet();
			return newID;
		}
	}

	/*
	 * Always normalize() after the vector is set to prevent strange behaviour
	 */
	public void setVector(Vector2d vector) {
		this.vector = vector;
		this.vector.normalize();
	}

	/*
	 * --- Constructor ---
	 */
	public Particle(double mass, double density, double x, double y) {

		this.mass = mass;
		this.density = density;
		calculateRadius();
		this.location = new Point2D.Double(x, y);
		uniqueId = getNewId();
	}

	/*
	 * --- Particle calculations ---
	 */

	/*
	 * Calculates a vector to indicate the direction of movement, the velocity
	 * is part of the vector and will be separated from it so we can use
	 * normalize() and have access to both values
	 */
	protected void calculateVector(Point start, Point end) {
		double vectorX = (double) (end.getX() - start.getX());
		double vectorY = (double) (end.getY() - start.getY());
		calculateRandomVelocityMultiplier();
		vectorX *= velocityMultiplier;
		vectorY *= velocityMultiplier;
		this.vector = new Vector2d(vectorX, vectorY);
		velocity = vector.length();
		vector.normalize();
	}

	/*
	 * Create a random number between 1 and 3 which will be used in the vector
	 * calculation to manipulate the particle velocity. This has to be done to
	 * meet the requirements of this project, which are at least one random
	 * parameter without controll possibilitys for the user
	 */
	protected void calculateRandomVelocityMultiplier() {
		int random = new Random().nextInt(3) + 1;
		velocityMultiplier = random;
	}

	/*
	 * We calculate the radius with the Math.log() method to get different sizes
	 * for particles without those radii getting to big, otherwise they would
	 * fill the whole panel. The density let the radius shrink exponential to
	 * the base 2 (the range is from 2^0,1 = 1,07 to 2^15 = 32768). A heavy
	 * particle with a high density is small, a light particle with a high
	 * density is tiny.
	 */
	protected void calculateRadius() {
		radius = Math.log(Math.E + mass / Math.pow(2, density));
	}

	/*
	 * With each timestep move a particle alongside its vector by the value of
	 * its velocity
	 */
	protected void moveParticle(double timeSteps) {
		double newX = vector.getX() * velocity / timeSteps;
		double newY = vector.getY() * velocity / timeSteps;
		location.setLocation(location.getX() + newX, location.getY() + newY);
	}

	/*
	 * We are using the Ellipse() class and forming it into a circle by
	 * multiplying the radius of the circle two times by two. The radius of this
	 * circle, combined with the color indicates the mass of a particle
	 */
	protected Shape getHullShape() {
		Ellipse2D circle = new Ellipse2D.Double(location.getX() - radius, location.getY() - radius, 2 * radius,
				2 * radius);
		return circle;
	}

	/*
	 * Analog to the hullShape. This inner circle is only half as big as the
	 * hullShape. This circle, combined with the color indicates the density of
	 * a particle
	 */
	protected Shape getCoreShape() {
		double coreRadius = radius * 0.5d;
		Ellipse2D circle = new Ellipse2D.Double(location.getX() - coreRadius, location.getY() - coreRadius,
				2 * coreRadius, 2 * coreRadius);
		return circle;
	}

	/*
	 * This method is used in CollisionFlag() to identify two particles, we
	 * simply overwrite toString() to retrun the id as a string
	 */
	@Override
	public String toString() {
		return uniqueId + "";
	}

}
